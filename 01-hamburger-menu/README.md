# 접근성을 고려한 햄버거 메뉴 UI 구현

## 구현 목표

- 버튼 클릭 시 메뉴 열기/닫기
- ESC 키로 메뉴 닫기
- 오버레이 영역 클릭 시 메뉴 닫기
- 메뉴 열릴 때 body 스크롤 막기
- 메뉴 내 포커스 트랩 적용 (Tab/Shift+Tab 순환)
- 접근성 속성 (`aria-expanded`, `aria-hidden`, `aria-controls`) 적용

---

## 주요 기능 설명

### ✅ 햄버거 메뉴 토글
- 메뉴 버튼 클릭 시 `.on` 클래스 토글
- 메뉴 닫기 버튼 또는 오버레이 클릭 시 닫힘

### ✅ 키보드 대응
- ESC 키를 누르면 메뉴가 닫힘
- 메뉴 열렸을 때 `Tab` / `Shift + Tab` 키로 포커스 순환

### ✅ 접근성
- `aria-expanded`, `aria-hidden`, `aria-controls` 동적 제어
- 스크린리더가 현재 메뉴 상태를 정확히 알 수 있도록 구현

### ✅ 오버레이 처리
- 메뉴가 열리면 어두운 배경 등장
- 배경 클릭 시 메뉴 닫힘

### ✅ 포커스 트랩
- 메뉴가 열려 있을 때, Tab 키 탐색이 메뉴 안에서만 순환

---

## 사용 기술

- HTML5
- CSS3
- Vanilla JavaScript (ES6+)
- WAI-ARIA 접근성 속성 적용

---

## 개발 중 막힌 점 & 해결 방법

[1] `aria-expanded`, `aria-controls`, `aria-hidden`의 역할을 명확히 이해하고, UI 상태에 따라 **동적으로 변경해 스크린리더가 메뉴의 열림 상태를 인식할 수 있도록 처리**하였습니다.
| 속성              | 위치                | 역할                                                                                           |
| --------------- | ----------------- | -------------------------------------------------------------------------------------------- |
| `aria-expanded` | 버튼 (`<button>`)   | \*\*이 버튼이 제어하는 대상이 현재 확장되어 있는지 (`true` or `false`)\*\*를 나타냄<br>→ 메뉴가 열리면 `true`, 닫히면 `false` |
| `aria-controls` | 버튼 (`<button>`)   | **이 버튼이 제어하는 요소의 ID를 명시**<br>→ 스크린리더가 이 버튼이 무엇을 여는지 알 수 있게 함                                 |
| `aria-hidden`   | 제어 대상 (`<nav>` 등) | **현재 요소가 보이는 상태인지 아닌지 명시**<br>→ `true`면 스크린리더가 이 영역을 읽지 않음                                   |

<br/>

[2] `keydown` vs `keyup` 이벤트의 차이를 비교하며, **중복 키 이벤트 방지를 위해 ESC 키 감지는 `keyup`**, **Tab 제어는 `keydown`**이 적합하다는 흐름을 실습을 통해 체감하게되었습니다.

| 구분        | `keydown`                                      | `keyup`                                         |
|-------------|------------------------------------------------|--------------------------------------------------|
| **발생 시점** | 키를 **누르자마자** 발생                       | 키를 **누른 후 떼었을 때** 발생                  |
| **반복 발생** | 계속 누르고 있으면 **반복해서 발생**           | **한 번만 발생**                                |
| **사용 예시** | `Tab`, `Arrow`, `Escape` 키 이벤트 제어 등 <br> 실시간 반응이 필요한 경우 | 입력 완료 후 처리 (예: Enter 누르고 난 뒤)      |
| **특징**     | 빠르게 반응함, 연속 실행 가능                   | 안정적인 처리에 적합 (반복 발생 없음)           |
| **주의점**   | 반복 발생으로 인해 중복 처리 방지 필요할 수 있음 | 딜레이가 있음 (누르고 나서 손 떼야 발생함)       |

- `keydown`은 `Tab`, `Shift + Tab` 감지 및 포커스 트랩 처리에 사용
- `keyup`은 `Escape` 키 눌렀다 **손 뗐을 때** 메뉴 닫기용으로 사용 → 중복 방지에 유리

<br/>

[3] `querySelectorAll("변수명")` vs `querySelectorAll(변수)`의 차이를 직접 실험하고,  
  문자열 변수는 따옴표 없이 전달해야 **CSS 선택자로 정상 해석됨**을 정확히 이해하였습니다.

[4] 포커스 트랩 구현을 위해 **의사코드로 로직을 설계하고, 이를 실제 JS로 구현**함으로써 키보드 기반 사용자도 메뉴 내에서 자연스럽게 탐색할 수 있도록 하였습니다.

[5] 메뉴 열림 상태를 추적하는 데 전역 변수(`let isOpen`)를 사용하지 않고,`classList.contains("on")`를 활용하여 **DOM 자체를 상태의 단일 소스로 활용**하는 구조적 접근을 익혔습니다.

[6] `firstFocus.focus()`가 처음 메뉴 열릴 때 동작하지 않았던 원인을 **렌더 타이밍 문제**로 파악했고, `requestAnimationFrame()`을 활용해 **렌더 직후 포커스를 안정적으로 적용**하는 방식으로 개선하였습니다.  
초기에는 `setTimeout(..., 0)`를 사용하는 것을 고려하였으나 정확한 랜더타이밍으로 보여지지않을 것을 고려하여  `requestAnimationFrame()`를 채택하게 되었습니다.

| 항목      | setTimeout             | requestAnimationFrame  |
| ------- | ---------------------- | ---------------------- |
| 실행 시점   | 다음 이벤트 루프              | 다음 렌더 직전               |
| 정확성     | 다소 흐릿함 (정확한 렌더 타이밍 아님) | ✅ 브라우저가 렌더 타이밍 정확히 맞춰줌 |






